name: Dotfiles CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

permissions:
  contents: read

concurrency:
  group: "${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}"
  cancel-in-progress: true

jobs:
  shellcheck:
    name: ShellCheck
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
      - name: Run ShellCheck
        uses: ludeeus/action-shellcheck@00b27aa7cb85167568cb48a3838b75f4265f2bca # master
        with:
          scandir: './scripts ./home'

  markdown-lint:
    name: Markdown Lint
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
      - name: Run markdownlint-cli2
        uses: DavidAnson/markdownlint-cli2-action@05f32210e84442804257b2a6f20b273450ec8265 # v19
        with:
          globs: '**/*.md'

  actionlint:
    name: Action Lint
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
      - name: Download actionlint
        run: bash <(curl https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash)
      - name: Run actionlint
        run: ./actionlint -color

  test-install:
    name: Test Install on ${{ matrix.os }}
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    needs: [shellcheck, markdown-lint, actionlint]
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    steps:
    - name: Checkout repository
      uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

    - name: Update base system packages (Ubuntu)
      if: runner.os == 'Linux'
      run: |
        echo "Updating base system to exclude package updates from overhead calculation..."
        sudo apt-get update
        sudo apt-get upgrade -y

    - name: Update base system packages (macOS)
      if: runner.os == 'macOS'
      run: |
        echo "Updating Homebrew to exclude package updates from overhead calculation..."
        brew update
        brew upgrade

    - name: Check disk space before installation (Unix)
      if: runner.os != 'Windows'
      run: |
        echo "==================================="
        echo "Disk Space Before Installation"
        echo "==================================="
        df -h
        echo ""
        # Store initial disk usage for volume containing home
        # Use portable df output parsing that works on both Linux and macOS
        if [[ "$(uname -s)" == "Darwin" ]]; then
          INITIAL_DISK_USED=$(df -k "$HOME" | tail -n 1 | awk '{print $3}')
        else
          INITIAL_DISK_USED=$(df --output=used "$HOME" | tail -n 1)
        fi
        echo "$INITIAL_DISK_USED" > /tmp/initial_disk_used.txt
        echo "Initial disk usage (home volume): $INITIAL_DISK_USED KB"
        echo ""
        echo "Home directory size:"
        du -sh "$HOME" 2>/dev/null || echo "Unable to calculate home directory size"

    - name: Check disk space before installation (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        Write-Host "==================================="
        Write-Host "Disk Space Before Installation"
        Write-Host "==================================="
        Get-PSDrive -PSProvider FileSystem | Where-Object { $_.Used -ne $null } | Format-Table -AutoSize
        Write-Host ""
        $drive = (Get-Item $HOME).PSDrive
        $initialUsed = $drive.Used
        $initialUsed | Out-File "$env:TEMP\initial_disk_used.txt"
        Write-Host "Initial disk usage (home volume): $([math]::Round($initialUsed / 1KB, 2)) KB"

    - name: Install dependencies (Ubuntu)
      if: runner.os == 'Linux'
      run: |
        # Note: apt-get update already run in "Update base system packages (Ubuntu)" step
        sudo apt-get install -y zsh

    - name: Install dependencies (macOS)
      if: runner.os == 'macOS'
      # Homebrew is pre-installed on macOS runners
      run: |
        # Note: brew update already run in "Update base system packages (macOS)" step
        # Install chezmoi if not present
        if ! command -v chezmoi >/dev/null 2>&1; then
          brew install chezmoi
        fi

    - name: Install chezmoi (Ubuntu)
      if: runner.os == 'Linux'
      run: |
        sudo sh -c "$(curl -fsLS get.chezmoi.io)" -- -b /usr/local/bin

    - name: Install chezmoi (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        # Install chezmoi via winget
        winget install --id twpayne.chezmoi --accept-source-agreements --accept-package-agreements
        
        # Add WinGet links directory to PATH for subsequent steps
        $wingetPath = "$env:LOCALAPPDATA\Microsoft\WinGet\Links"
        Write-Host "Adding $wingetPath to PATH"
        echo "$wingetPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

    - name: Initialize and Apply Dotfiles (Unix)
      if: runner.os != 'Windows'
      run: |
        # Use 'time' to benchmarking installation (T026)
        # We use --source . to use the checked-out repo
        # We assume no secrets are strictly blocking for this basic CI smoke test
        
        # Create chezmoi config directory and copy config file
        mkdir -p "$HOME/.config/chezmoi"
        cp .chezmoi.toml "$HOME/.config/chezmoi/chezmoi.toml"
        
        echo "Starting Chezmoi Apply..."
        time chezmoi init --apply --source . --verbose

    - name: Initialize and Apply Dotfiles (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        # Create chezmoi config directory and copy config file
        New-Item -ItemType Directory -Path "$HOME\.config\chezmoi" -Force | Out-Null
        Copy-Item .chezmoi.toml "$HOME\.config\chezmoi\chezmoi.toml"
        
        Write-Host "Starting Chezmoi Apply..."
        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
        chezmoi init --apply --source . --verbose
        $stopwatch.Stop()
        Write-Host "Installation took $($stopwatch.Elapsed.TotalSeconds) seconds"

    - name: Run Validation Script (Unix)
      if: runner.os != 'Windows'
      run: |
        chmod +x scripts/validate-installation.sh
        ./scripts/validate-installation.sh

    - name: Run Validation Script (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        & scripts/validate-installation-windows.ps1

    - name: Check disk space after installation (Unix)
      if: always() && runner.os != 'Windows'
      run: |
        echo ""
        echo "==================================="
        echo "Disk Space After Installation"
        echo "==================================="
        df -h
        echo ""
        
        # Calculate disk overhead for root filesystem
        if [ ! -f /tmp/initial_disk_used.txt ]; then
          echo "Error: Initial disk usage file not found"
          exit 1
        fi
        
        INITIAL_DISK_USED=$(cat /tmp/initial_disk_used.txt)
        if ! [[ "$INITIAL_DISK_USED" =~ ^[0-9]+$ ]]; then
          echo "Error: Initial disk usage is not a valid number"
          exit 1
        fi
        
        # Get final disk usage using portable df parsing
        if [[ "$(uname -s)" == "Darwin" ]]; then
          FINAL_DISK_USED=$(df -k "$HOME" | tail -n 1 | awk '{print $3}')
        else
          FINAL_DISK_USED=$(df --output=used "$HOME" | tail -n 1)
        fi
        
        OVERHEAD_KB=$((FINAL_DISK_USED - INITIAL_DISK_USED))
        # Note: Integer division truncates to nearest MB (rounds down)
        OVERHEAD_MB=$((OVERHEAD_KB / 1024))
        
        echo "==================================="
        echo "Disk Space Overhead Summary"
        echo "==================================="
        echo "Initial disk used: $((INITIAL_DISK_USED / 1024)) MB"
        echo "Final disk used:   $((FINAL_DISK_USED / 1024)) MB"
        if [ $OVERHEAD_KB -ge 0 ]; then
          # Calculate GB with 2 decimal places using shell arithmetic
          # Rearranged to avoid potential overflow: (KB / 1024) * 100 / 1024
          OVERHEAD_GB_INT=$((OVERHEAD_KB / 1024 / 1024))
          OVERHEAD_GB_DEC=$(((OVERHEAD_KB * 100 / 1024 / 1024) % 100))
          printf "Disk overhead:     %d MB (%d.%02d GB)\n" "$OVERHEAD_MB" "$OVERHEAD_GB_INT" "$OVERHEAD_GB_DEC"
        else
          # For negative values, calculate absolute value
          OVERHEAD_MB_ABS=$(( (-OVERHEAD_KB) / 1024 ))
          echo "Disk overhead:     -${OVERHEAD_MB_ABS} MB [disk space freed]"
        fi
        echo "==================================="
        
        echo ""
        echo "Home directory size:"
        du -sh "$HOME" 2>/dev/null || echo "Unable to calculate home directory size"
        
        # Also show breakdown of major directories in home
        echo ""
        echo "Top directories by size in home:"
        # Using du directly is faster than find with -exec
        du -sh "$HOME"/* "$HOME"/.[!.]* 2>/dev/null | sort -hr | head -20 || echo "Unable to list directories"
        
        # Persist disk overhead for summary step
        echo "OVERHEAD_KB=$OVERHEAD_KB" > /tmp/disk_overhead.txt
        echo "OVERHEAD_MB=$OVERHEAD_MB" >> /tmp/disk_overhead.txt

    - name: Check disk space after installation (Windows)
      if: always() && runner.os == 'Windows'
      shell: pwsh
      run: |
        Write-Host ""
        Write-Host "==================================="
        Write-Host "Disk Space After Installation"
        Write-Host "==================================="
        Get-PSDrive -PSProvider FileSystem | Where-Object { $_.Used -ne $null } | Format-Table -AutoSize
        Write-Host ""
        
        $initialFile = "$env:TEMP\initial_disk_used.txt"
        if (-not (Test-Path $initialFile)) {
          Write-Host "Error: Initial disk usage file not found"
          exit 1
        }
        
        $initialUsed = [decimal](Get-Content $initialFile)
        $drive = (Get-Item $HOME).PSDrive
        $finalUsed = $drive.Used
        
        $overheadBytes = $finalUsed - $initialUsed
        $overheadKB = [math]::Round($overheadBytes / 1KB, 2)
        $overheadMB = [math]::Round($overheadBytes / 1MB, 2)
        $overheadGB = [math]::Round($overheadBytes / 1GB, 2)
        
        Write-Host "==================================="
        Write-Host "Disk Space Overhead Summary"
        Write-Host "==================================="
        Write-Host "Initial disk used: $([math]::Round($initialUsed / 1MB, 2)) MB"
        Write-Host "Final disk used:   $([math]::Round($finalUsed / 1MB, 2)) MB"
        Write-Host "Disk overhead:     $overheadMB MB ($overheadGB GB)"
        Write-Host "==================================="
        
        # Persist for summary
        "OVERHEAD_KB=$overheadKB" | Out-File "$env:TEMP\disk_overhead.txt"
        "OVERHEAD_MB=$overheadMB" | Add-Content "$env:TEMP\disk_overhead.txt"

    - name: Generate Installation Report (Unix)
      if: always() && runner.os != 'Windows'
      run: |
        # Generate Job Summary
        {
          echo "### Installation Report (${{ matrix.os }}) :bar_chart:"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"

        # Load test counts if available
        if [ -f /tmp/validation_counts.txt ]; then
            source /tmp/validation_counts.txt
        else
            PASSED_TESTS="0"
            FAILED_TESTS="0"
            TOTAL_TESTS="0"
        fi

        # Load disk overhead if available
        if [ -f /tmp/disk_overhead.txt ]; then
            source /tmp/disk_overhead.txt
        else
            OVERHEAD_KB="0"
            OVERHEAD_MB="0"
            OVERHEAD_DISPLAY="N/A"
        fi

        # Determine status icon
        # We consider it a success if:
        # 1. Validation ran and reported 0 failures
        # 2. Total tests > 0 (it actually ran)
        # 3. The overall job status is not already failure (e.g. from install step)
        if [ "$FAILED_TESTS" -eq 0 ] && [ "$TOTAL_TESTS" -gt 0 ] && [ "${{ job.status }}" != "failure" ]; then
             STATUS="✅ Success"
        else
             STATUS="❌ Failure"
        fi

        {
          echo "| Metric | Value |"
          echo "| :--- | :--- |"
          echo "| **Status** | $STATUS |"
          echo "| **Tests Run** | $TOTAL_TESTS |"
          echo "| **Tests Passed** | $PASSED_TESTS |"
        } >> "$GITHUB_STEP_SUMMARY"

        if [ "$OVERHEAD_DISPLAY" != "N/A" ]; then
            if [ "$OVERHEAD_KB" -ge 0 ]; then
              OVERHEAD_DISPLAY="${OVERHEAD_MB} MB"
            else
              OVERHEAD_MB_ABS=$(( (-OVERHEAD_KB) / 1024 ))
              OVERHEAD_DISPLAY="-${OVERHEAD_MB_ABS} MB (freed)"
            fi
        fi
        echo "| **Disk Overhead** | $OVERHEAD_DISPLAY |" >> "$GITHUB_STEP_SUMMARY"

    - name: Generate Installation Report (Windows)
      if: always() && runner.os == 'Windows'
      shell: pwsh
      run: |
        # Generate Job Summary
        @"
        ### Installation Report (${{ matrix.os }}) :bar_chart:

        "@ | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append

        # Load test counts if available
        $countsFile = "$env:TEMP\validation_counts.txt"
        if (Test-Path $countsFile) {
            Get-Content $countsFile | ForEach-Object {
                if ($_ -match '^(\w+)=(.+)$') {
                    Set-Variable -Name $matches[1] -Value $matches[2]
                }
            }
        } else {
            $PASSED_TESTS = "0"
            $FAILED_TESTS = "0"
            $TOTAL_TESTS = "0"
        }

        # Load disk overhead if available
        $overheadFile = "$env:TEMP\disk_overhead.txt"
        if (Test-Path $overheadFile) {
            Get-Content $overheadFile | ForEach-Object {
                if ($_ -match '^(\w+)=(.+)$') {
                    Set-Variable -Name $matches[1] -Value $matches[2]
                }
            }
            $OVERHEAD_DISPLAY = "$OVERHEAD_MB MB"
        } else {
            $OVERHEAD_KB = "0"
            $OVERHEAD_MB = "0"
            $OVERHEAD_DISPLAY = "N/A"
        }

        # Determine status
        if ($FAILED_TESTS -eq 0 -and $TOTAL_TESTS -gt 0 -and "${{ job.status }}" -ne "failure") {
            $STATUS = ":white_check_mark: Success"
        } else {
            $STATUS = ":x: Failure"
        }

        @"
        | Metric | Value |
        | :--- | :--- |
        | **Status** | $STATUS |
        | **Tests Run** | $TOTAL_TESTS |
        | **Tests Passed** | $PASSED_TESTS |
        | **Disk Overhead** | $OVERHEAD_DISPLAY |
        "@ | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append

    - name: Upload Test Results
      if: failure()
      uses: actions/upload-artifact@v6
      with:
        name: test-results-${{ matrix.os }}
        path: |
          home/
 